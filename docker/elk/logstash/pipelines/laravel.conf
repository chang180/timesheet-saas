input {
  beats {
    port => 5044
  }
}

filter {
  # 首先處理多行日誌 - Filebeat 已經將多行合併，但我們需要分離堆疊追蹤
  # 如果 message 包含 [stacktrace]，分離它
  if [message] =~ /\[stacktrace\]/ {
    ruby {
      code => "
        msg = event.get('message')
        if msg
          parts = msg.split(/\\[stacktrace\\]/, 2)
          if parts.length == 2
            event.set('message', parts[0].strip)
            event.set('stack_trace', parts[1].strip)
          end
        end
      "
    }
  }

  # 解析 Laravel Monolog 標準格式
  # 格式: [2024-01-15 10:30:45] local.ERROR: Message here {"exception":"..."}
  # Laravel 使用格式: [YYYY-MM-DD HH:mm:ss] environment.LEVEL: message
  # 使用自定義模式匹配日期時間格式 YYYY-MM-DD HH:mm:ss
  grok {
    match => {
      "message" => "^\[%{YEAR:year}-%{MONTHNUM:month}-%{MONTHDAY:day} %{TIME:time}\] %{WORD:environment}\.%{LOGLEVEL:log_level}: %{GREEDYDATA:log_message}"
    }
    overwrite => ["message"]
  }
  
  # 合併日期時間字段
  if [year] and [month] and [day] and [time] {
    mutate {
      add_field => { "log_timestamp" => "%{year}-%{month}-%{day} %{time}" }
      remove_field => ["year", "month", "day", "time"]
    }
  }

  # 如果 grok 匹配失敗，嘗試解析其他格式（沒有環境名稱）
  if "_grokparsefailure" in [tags] {
    grok {
      match => {
        "message" => "^\[%{DATESTAMP:log_timestamp}\] %{LOGLEVEL:log_level}: %{GREEDYDATA:log_message}"
      }
      overwrite => ["message"]
      add_field => { "environment" => "unknown" }
    }
  }

  # 如果還是失敗，嘗試最基本的格式（只有時間戳）
  if "_grokparsefailure" in [tags] {
    grok {
      match => {
        "message" => "^\[%{DATESTAMP:log_timestamp}\] %{GREEDYDATA:log_message}"
      }
      overwrite => ["message"]
      add_field => { 
        "environment" => "unknown"
        "log_level" => "info"
      }
    }
  }
  
  # 移除 grok 失敗標籤（如果所有嘗試都失敗，至少保留原始訊息）
  if "_grokparsefailure" in [tags] {
    mutate {
      remove_tag => ["_grokparsefailure"]
      add_field => {
        "environment" => "unknown"
        "log_level" => "info"
      }
    }
  }

  # 解析 JSON context（如果存在）
  # Laravel 日誌格式: message {"exception":"...", "userId":1, ...}
  if [log_message] =~ /\{\".*\"\}$/ {
    ruby {
      code => "
        begin
          # 嘗試從訊息末尾提取 JSON
          msg = event.get('log_message')
          if msg && msg =~ /\{\".*\"\}$/
            # 找到最後一個完整的 JSON 對象
            json_match = msg.match(/\{.*\}$/m)
            if json_match
              json_part = json_match[0]
              parsed = JSON.parse(json_part)
              event.set('context', parsed)
              # 移除 JSON 部分，保留純訊息
              event.set('log_message', msg.gsub(/\s*\{.*\}$/m, '').strip)
            end
          end
        rescue => e
          # JSON 解析失敗時忽略
        end
      "
    }
  }

  # 解析例外資訊（如果存在）
  # Laravel 可能將 exception 作為字符串存儲，格式: "[object] (ParseError(...))"
  if [context][exception] {
    # 嘗試解析 exception 字符串格式
    if [context][exception] =~ /\[object\] \(([^:]+)/ {
      grok {
        match => {
          "[context][exception]" => "\[object\] \(%{WORD:exception_class}"
        }
      }
    }
    
    # 如果 context.exception 是對象，提取字段
    if [context][exception][class] {
      mutate {
        add_field => {
          "exception_class" => "%{[context][exception][class]}"
          "exception_message" => "%{[context][exception][message]}"
          "exception_file" => "%{[context][exception][file]}"
          "exception_line" => "%{[context][exception][line]}"
        }
      }
    }
  }
  
  # 處理堆疊追蹤（可能在 message 中，以 [stacktrace] 開頭）
  if [log_message] =~ /\[stacktrace\]/ {
    ruby {
      code => "
        msg = event.get('log_message')
        if msg && msg.include?('[stacktrace]')
          parts = msg.split('[stacktrace]', 2)
          event.set('log_message', parts[0].strip)
          event.set('stack_trace', parts[1].strip) if parts[1]
        end
      "
    }
  }

  # 提取用戶 ID 和請求 ID（如果存在）
  if [context][user_id] {
    mutate {
      add_field => { "user_id" => "%{[context][user_id]}" }
    }
  }

  if [context][request_id] {
    mutate {
      add_field => { "request_id" => "%{[context][request_id]}" }
    }
  }

  # 解析時間戳記
  date {
    match => ["log_timestamp", "yyyy-MM-dd HH:mm:ss"]
    target => "@timestamp"
    timezone => "UTC"
  }

  # 如果日期解析失敗，使用當前時間
  if "_dateparsefailure" in [tags] {
    mutate {
      remove_tag => ["_dateparsefailure"]
    }
  }

  # 標準化欄位名稱
  mutate {
    rename => {
      "log_level" => "level"
      "log_message" => "message"
    }
    lowercase => ["level"]
  }

  # 添加應用程式標籤
  mutate {
    add_field => {
      "application" => "laravel"
      "log_type" => "application"
    }
  }

  # 移除不必要的欄位
  mutate {
    remove_field => ["agent", "ecs", "input", "log"]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "laravel-logs-%{+YYYY.MM.dd}"
    # 讓 Elasticsearch 自動創建索引和 mapping
  }

  # 開發環境可以啟用 stdout 輸出以便除錯
  # stdout {
  #   codec => rubydebug
  # }
}
